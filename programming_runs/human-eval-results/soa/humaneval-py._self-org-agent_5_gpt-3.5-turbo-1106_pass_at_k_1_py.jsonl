{"name": "HumanEval_23_strlen", "language": "py", "prompt": "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_23_strlen.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "strlen", "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n\ndef test_check():\n    check(strlen)\n\ntest_check()\n", "is_solved": true, "test_feedback": [], "solution": "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n    length = calculate_length(string)\n    return length\n\ndef calculate_length(string: str) ->int:\n    \"\"\" Calculate the length of a given string.\n\n    Parameters:\n    string: str - The input string.\n\n    Returns:\n    int - The length of the string.\n\n    >>> calculate_length('')\n    0\n    >>> calculate_length('abc')\n    3\n    \"\"\"\n    return len(string)\n"}
{"name": "HumanEval_89_encrypt", "language": "py", "prompt": "def encrypt(s: str) -> str:\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    >>> encrypt('hi')\n    'lm'\n    >>> encrypt('asdfghjkl')\n    'ewhjklnop'\n    >>> encrypt('gf')\n    'kj'\n    >>> encrypt('et')\n    'ix'\n    \"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_89_encrypt.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "encrypt", "test": "def check(candidate):\n    assert candidate('hi') == 'lm'\n    assert candidate('asdfghjkl') == 'ewhjklnop'\n    assert candidate('gf') == 'kj'\n    assert candidate('et') == 'ix'\n    assert candidate('faewfawefaewg') == 'jeiajeaijeiak'\n    assert candidate('hellomyfriend') == 'lippsqcjvmirh'\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') == 'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n    assert candidate('a') == 'e'\n\ndef test_check():\n    check(encrypt)\n\ntest_check()\n", "is_solved": true, "test_feedback": [], "solution": "def encrypt(s: str) -> str:\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    >>> encrypt('hi')\n    'lm'\n    >>> encrypt('asdfghjkl')\n    'ewhjklnop'\n    >>> encrypt('gf')\n    'kj'\n    >>> encrypt('et')\n    'ix'\n    \"\"\"\n    rotated_string = rotate_alphabet(s)\n    return rotated_string\n\ndef rotate_alphabet(s: str) ->str:\n    \"\"\"Rotate the alphabet in a manner such that the letters shift down by two multiplied to two places.\n\n    Parameters:\n    s: str - The input string to be encrypted.\n\n    Returns:\n    str - The encrypted string.\n\n    >>> rotate_alphabet('hi')\n    'lm'\n    >>> rotate_alphabet('asdfghjkl')\n    'ewhjklnop'\n    >>> rotate_alphabet('gf')\n    'kj'\n    >>> rotate_alphabet('et')\n    'ix'\n    \"\"\"\n    result = ''\n    for char in s:\n        if char.isalpha():\n            shifted = ord(char) + 2 * 2\n            if char.islower():\n                if shifted > ord('z'):\n                    shifted -= 26\n            elif shifted > ord('Z'):\n                shifted -= 26\n            result += chr(shifted)\n        else:\n            result += char\n    return result\n"}
{"name": "HumanEval_95_check_dict_case", "language": "py", "prompt": "from typing import Dict\n\ndef check_dict_case(dict: Dict[str, str]) -> bool:\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    >>> check_dict_case({ 'a': 'apple', 'b': 'banana' })\n    True\n    >>> check_dict_case({ 'a': 'apple', 'A': 'banana', 'B': 'banana' })\n    False\n    >>> check_dict_case({ 'a': 'apple', 8: 'banana', 'a': 'apple' })\n    False\n    >>> check_dict_case({ 'Name': 'John', 'Age': '36', 'City': 'Houston' })\n    False\n    >>> check_dict_case({ 'STATE': 'NC', 'ZIP': '12345' })\n    True\n    \"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_95_check_dict_case.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "check_dict_case", "test": "def check(candidate):\n    assert candidate({ 'p': 'pineapple', 'b': 'banana' }) == True\n    assert candidate({ 'p': 'pineapple', 'A': 'banana', 'B': 'banana' }) == False\n    assert candidate({ 'p': 'pineapple', '5': 'banana', 'a': 'apple' }) == False\n    assert candidate({ 'Name': 'John', 'Age': '36', 'City': 'Houston' }) == False\n    assert candidate({ 'STATE': 'NC', 'ZIP': '12345' }) == True\n    assert candidate({ 'fruit': 'Orange', 'taste': 'Sweet' }) == True\n    assert candidate({  }) == False\n\ndef test_check():\n    check(check_dict_case)\n\ntest_check()\n", "is_solved": true, "test_feedback": [], "solution": "def check_dict_case(dict: Dict[str, str]) -> bool:\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    >>> check_dict_case({ 'a': 'apple', 'b': 'banana' })\n    True\n    >>> check_dict_case({ 'a': 'apple', 'A': 'banana', 'B': 'banana' })\n    False\n    >>> check_dict_case({ 'a': 'apple', 8: 'banana', 'a': 'apple' })\n    False\n    >>> check_dict_case({ 'Name': 'John', 'Age': '36', 'City': 'Houston' })\n    False\n    >>> check_dict_case({ 'STATE': 'NC', 'ZIP': '12345' })\n    True\n    \"\"\"\n    if not dict:\n        return False\n    return check_keys_case(dict)\n\ndef check_keys_case(dict: Dict[str, str]) ->bool:\n    \"\"\"\n    Check if all keys in the dictionary are either all in lower case or all in upper case.\n\n    Parameters:\n    dict: Dict[str, str] - A dictionary with string keys.\n\n    Returns:\n    bool - True if all keys are in lower case or upper case, False otherwise.\n\n    >>> check_keys_case({ 'a': 'apple', 'b': 'banana' })\n    True\n    >>> check_keys_case({ 'a': 'apple', 'A': 'banana', 'B': 'banana' })\n    False\n    >>> check_keys_case({ 'STATE': 'NC', 'ZIP': '12345' })\n    True\n    \"\"\"\n    keys = list(dict.keys())\n    return all(key.islower() for key in keys) or all(key.isupper() for key in\n        keys)\n"}
{"name": "HumanEval_85_add", "language": "py", "prompt": "from typing import List\n\ndef add(lst: List[int]) -> int:\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n    >>> add([4, 2, 6, 7])\n    2\n    \"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_85_add.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add", "test": "def check(candidate):\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\ndef test_check():\n    check(add)\n\ntest_check()\n", "is_solved": false, "test_feedback": [], "solution": "def add(lst: List[int]) ->int:\n    \"\"\"Given a non-empty list of integers lst, add all the even elements.\n    If there are no even elements, return 0.\n\n    Examples:\n    >>> add([4, 2, 6, 7])\n    12\n    \"\"\"\n    if not lst:\n        return 0\n    even_numbers = [num for num in lst if num % 2 == 0]\n    total = sum_list(even_numbers)\n    return total\n\n\ndef add(numbers: List[int]) ->int:\n    \"\"\"\n    Given a list of integers, return the sum of all even elements.\n    If the list is empty, return 0.\n    \"\"\"\n    if not numbers:\n        return 0\n    even_numbers = [num for num in numbers if num % 2 == 0]\n    return sum(even_numbers)\n\n\ndef add(numbers: List[int]) ->int:\n    \"\"\"Calculates the sum of all even elements in a given list of integers.\n\n    Parameters:\n    numbers: List[int] - A list of integers.\n\n    Returns:\n    int - The sum of all even elements in the list. If the list is empty, return 0.\n\n    Examples:\n    >>> add([2, 4, 6])\n    12\n    \"\"\"\n    if not numbers:\n        return 0\n    even_numbers = [num for num in numbers if num % 2 == 0]\n    return sum(even_numbers)\n"}
{"name": "HumanEval_140_fix_spaces", "language": "py", "prompt": "def fix_spaces(text: str) -> str:\n    \"\"\"\n    Given a string text, replace all spaces in it with underscores, \n    and if a string has more than 2 consecutive spaces, \n    then replace all consecutive spaces with - \n    \n    >>> fix_spaces(' Example')\n    'Example'\n    >>> fix_spaces(' Example 1')\n    'Example_1'\n    >>> fix_spaces(' Example 2')\n    '_Example_2'\n    >>> fix_spaces(' Example 3')\n    '_Example-3'\n    \"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_140_fix_spaces.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "fix_spaces", "test": "def check(candidate):\n    assert candidate('Example') == 'Example'\n    assert candidate('Mudasir Hanif ') == 'Mudasir_Hanif_'\n    assert candidate('Yellow Yellow  Dirty  Fellow') == 'Yellow_Yellow__Dirty__Fellow'\n    assert candidate('Exa   mple') == 'Exa-mple'\n    assert candidate('   Exa 1 2 2 mple') == '-Exa_1_2_2_mple'\n\ndef test_check():\n    check(fix_spaces)\n\ntest_check()\n", "is_solved": false, "test_feedback": [], "solution": "def fix_spaces(text: str) -> str:\n    \"\"\"\n    Given a string text, replace all spaces in it with underscores, \n    and if a string has more than 2 consecutive spaces, \n    then replace all consecutive spaces with - \n    \n    >>> fix_spaces(' Example')\n    'Example'\n    >>> fix_spaces(' Example 1')\n    'Example_1'\n    >>> fix_spaces(' Example 2')\n    '_Example_2'\n    >>> fix_spaces(' Example 3')\n    '_Example-3'\n    \"\"\"\n    text = replace_spaces_with_underscores(text)\n    text = replace_consecutive_spaces(text)\n    return text\n\ndef replace_spaces_with_underscores(text: str) ->str:\n    \"\"\"\n    Replace all spaces in the given string with underscores.\n\n    Parameters:\n    text: str - The input string.\n\n    Returns:\n    str - The input string with spaces replaced by underscores.\n\n    >>> replace_spaces_with_underscores(' Example')\n    '_Example'\n    >>> replace_spaces_with_underscores(' Example 1')\n    '_Example_1'\n    >>> replace_spaces_with_underscores(' Example 2')\n    '_Example_2'\n    >>> replace_spaces_with_underscores(' Example 3')\n    '_Example_3'\n    \"\"\"\n    return text.replace(' ', '_')\n\n\ndef replace_consecutive_spaces(text: str) ->str:\n    \"\"\"\n    Replace more than 2 consecutive spaces in the given string with a single hyphen.\n\n    Parameters:\n    text: str - The input string.\n\n    Returns:\n    str - The input string with consecutive spaces replaced by a hyphen.\n\n    >>> replace_consecutive_spaces(' Example')\n    'Example'\n    >>> replace_consecutive_spaces(' Example 1')\n    'Example_1'\n    >>> replace_consecutive_spaces(' Example 2')\n    '_Example_2'\n    >>> replace_consecutive_spaces(' Example 3')\n    '_Example-3'\n    \"\"\"\n    import re\n    return re.sub('\\\\s{2,}', '-', text)\n"}
{"name": "HumanEval_63_fibfib", "language": "py", "prompt": "def fibfib(n: int) -> int:\n    \"\"\"The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_63_fibfib.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "fibfib", "test": "def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\ndef test_check():\n    check(fibfib)\n\ntest_check()\n", "is_solved": false, "test_feedback": [], "solution": "def fibfib(n: int) ->int:\n    \"\"\"The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        return compute_fibfib(n)\n\n\ndef compute_fibfib(n: int) ->int:\n    \"\"\"Compute the n-th element of the fibfib number sequence.\n\n    The fibfib number sequence is defined as follows:\n    fibfib(0) = 0\n    fibfib(1) = 1\n    fibfib(n) = fibfib(n-1) + fibfib(n-2) * fibfib(n-1)\n\n    Parameters:\n    n: int - The index of the element to compute.\n\n    Returns:\n    int - The n-th element of the fibfib number sequence.\n\n    >>> compute_fibfib(3)\n    2\n    >>> compute_fibfib(5)\n    5\n    >>> compute_fibfib(8)\n    21\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        a, b = 0, 1\n        for _ in range(2, n):\n            a, b = b, a + b * a\n        return b\n"}
{"name": "HumanEval_151_double_the_difference", "language": "py", "prompt": "from typing import List\n\ndef double_the_difference(lst: List[float]) -> int:\n    \"\"\"\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    >>> double_the_difference([1, 3, 2, 0])\n    10\n    >>> double_the_difference([-1, -2, 0])\n    0\n    >>> double_the_difference([9, -2])\n    81\n    >>> double_the_difference([0])\n    0\n   \n    If the input list is empty, return 0.\n    \"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_151_double_the_difference.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "double_the_difference", "test": "def check(candidate):\n    assert candidate([]) == 0\n    assert candidate([5.0, 4.0]) == 25\n    assert candidate([0.1, 0.2, 0.3]) == 0\n    assert candidate([-10.0, -20.0, -30.0]) == 0\n    assert candidate([-1.0, -2.0, 8.0]) == 0\n    assert candidate([0.2, 3.0, 5.0]) == 34\n    assert candidate([-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]) == 165\n\ndef test_check():\n    check(double_the_difference)\n\ntest_check()\n", "is_solved": false, "test_feedback": [], "solution": "def double_the_difference(lst: List[float]) ->int:\n    \"\"\"\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    Parameters:\n    lst: List[float] - A list of numbers.\n    \n    Returns:\n    int - The sum of squares of the odd numbers in the list.\n    \n    >>> double_the_difference([1, 3, 2, 0])\n    10\n    >>> double_the_difference([-1, -2, 0])\n    0\n    >>> double_the_difference([9, -2])\n    81\n    >>> double_the_difference([0])\n    0\n    \"\"\"\n    odd_numbers = filter_odd_numbers(lst)\n    squared_numbers = square_numbers(odd_numbers)\n    total = sum(squared_numbers)\n    return total\n\n\ndef filter_odd_numbers(lst: List[float]) ->List[float]:\n    \"\"\"\n    Filter the odd numbers from the given list of numbers.\n    \n    Parameters:\n    lst: List[float] - A list of numbers.\n    \n    Returns:\n    List[float] - A list of the odd numbers from the input list.\n    \n    >>> filter_odd_numbers([1, 3, 2, 0])\n    [1, 3]\n    >>> filter_odd_numbers([-1, -2, 0])\n    []\n    >>> filter_odd_numbers([9, -2])\n    [9]\n    >>> filter_odd_numbers([0])\n    []\n    \"\"\"\n    return [num for num in lst if num % 2 != 0]\n\n\ndef square_numbers(lst: List[float]) ->List[float]:\n    \"\"\"\n    Square each number in the given list of numbers.\n    \n    Parameters:\n    lst: List[float] - A list of numbers.\n    \n    Returns:\n    List[float] - A list of the squared numbers.\n    \n    >>> square_numbers([1, 3])\n    [1, 9]\n    >>> square_numbers([9])\n    [81]\n    >>> square_numbers([0])\n    [0]\n    \"\"\"\n    return [(num ** 2) for num in lst]\n\n\ndef sum_squared_numbers(lst: List[float]) ->int:\n    \"\"\"\n    Calculate the sum of the squared numbers in the given list.\n    \n    Parameters:\n    lst: List[float] - A list of numbers.\n    \n    Returns:\n    int - The sum of the squared numbers.\n    \n    >>> sum_squared_numbers([1, 9])\n    10\n    >>> sum_squared_numbers([81])\n    81\n    >>> sum_squared_numbers([0])\n    0\n    \"\"\"\n    return sum([(x ** 2) for x in lst])\n"}
{"name": "HumanEval_22_filter_integers", "language": "py", "prompt": "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {  }, []])\n    [1, 2, 3]\n    \"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_22_filter_integers.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "filter_integers", "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {  }, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n\ndef test_check():\n    check(filter_integers)\n\ntest_check()\n", "is_solved": true, "test_feedback": [], "solution": "def filter_integers(values: List[Any]) ->List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {  }, []])\n    [1, 2, 3]\n    >>> filter_integers([0, '0', False])\n    [0]\n    >>> filter_integers([True, 10, 3.5, 'hello'])\n    [True, 10]\n    \"\"\"\n    integers = [value for value in values if isinstance(value, int) or\n        isinstance(value, bool)]\n    return integers\n\n\ndef extract_integers(values: List[Any]) ->List[int]:\n    \"\"\" Extract integers from a list of any python values\n    Parameters:\n    values: List[Any] - A list of any python values\n    \n    Returns:\n    List[int] - A list of integers extracted from the input list\n    \n    >>> extract_integers(['a', 3.14, 5])\n    [5]\n    >>> extract_integers([1, 2, 3, 'abc', {  }, []])\n    [1, 2, 3]\n    \"\"\"\n    return [x for x in values if isinstance(x, int)]\n"}
{"name": "HumanEval_41_car_race_collision", "language": "py", "prompt": "def car_race_collision(n: int) -> int:\n    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of n cars\n    are driving right to left.   The two sets of cars start out being very far from\n    each other.  All cars move in the same speed.  Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.\n    \"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_41_car_race_collision.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "car_race_collision", "test": "def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\ndef test_check():\n    check(car_race_collision)\n\ntest_check()\n", "is_solved": false, "test_feedback": [], "solution": "def car_race_collision(n: int) ->int:\n    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of n cars\n    are driving right to left.   The two sets of cars start out being very far from\n    each other.  All cars move in the same speed.  Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.\n    \"\"\"\n    if n == 1:\n        return 0\n    left_to_right_cars = generate_left_to_right_cars(n)\n    right_to_left_cars = generate_right_to_left_cars(n)\n    collisions = count_collisions(left_to_right_cars, right_to_left_cars)\n    return collisions\n\n\ndef generate_left_to_right_cars(n: int) ->List[int]:\n    \"\"\"\n    Generate the initial positions of cars moving from left to right.\n\n    Parameters:\n    n: int - The number of cars.\n\n    Returns:\n    List[int] - A list of initial positions of cars moving from left to right.\n\n    >>> generate_left_to_right_cars(3)\n    [1, 3, 5]\n    >>> generate_left_to_right_cars(5)\n    [1, 3, 5, 7, 9]\n    >>> generate_left_to_right_cars(1)\n    [1]\n    \"\"\"\n    return [(i * 2 + 1) for i in range(n)]\n\n\ndef generate_right_to_left_cars(n: int) ->List[int]:\n    \"\"\"\n    Generate the initial positions of cars moving from right to left.\n\n    Parameters:\n    n: int - The number of cars.\n\n    Returns:\n    List[int] - A list of initial positions of cars moving from right to left.\n\n    >>> generate_right_to_left_cars(3)\n    [2, 4, 6]\n    >>> generate_right_to_left_cars(5)\n    [2, 4, 6, 8, 10]\n    >>> generate_right_to_left_cars(1)\n    [2]\n    \"\"\"\n    return [(2 * (i + 1)) for i in range(n)]\n\n\ndef count_collisions(left_to_right_cars: List[int], right_to_left_cars:\n    List[int]) ->int:\n    \"\"\"\n    Count the number of collisions between the left-to-right and right-to-left moving cars.\n\n    Parameters:\n    left_to_right_cars: List[int] - A list of initial positions of cars moving from left to right.\n    right_to_left_cars: List[int] - A list of initial positions of cars moving from right to left.\n\n    Returns:\n    int - The number of collisions between the two sets of cars.\n\n    >>> count_collisions([1, 3, 5], [2, 4, 6])\n    3\n    >>> count_collisions([1, 3, 5, 7, 9], [2, 4, 6, 8, 10])\n    5\n    >>> count_collisions([1], [2])\n    1\n    \"\"\"\n    collisions = 0\n    for left_car in left_to_right_cars:\n        for right_car in right_to_left_cars:\n            if left_car > right_car:\n                collisions += 1\n    return collisions\n"}
{"name": "HumanEval_17_parse_music", "language": "py", "prompt": "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_17_parse_music.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "parse_music", "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n\ndef test_check():\n    check(parse_music)\n\ntest_check()\n", "is_solved": true, "test_feedback": [], "solution": "def parse_music(music_string: str) ->List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    notes = parse_notes(music_string)\n    beats = convert_notes_to_beats(notes)\n    return beats\n\n\ndef parse_notes(music_string: str) ->List[str]:\n    \"\"\"Parse the music string into individual notes.\n\n    Parameters:\n    music_string: str - A string representing musical notes in a special ASCII format.\n\n    Returns:\n    List[str] - A list of individual notes.\n\n    >>> parse_notes('o o| .| o| o| .| .| .| .| o o')\n    ['o', 'o|', '.|', 'o|', 'o|', '.|', '.|', '.|', '.|', 'o', 'o']\n    \"\"\"\n    return music_string.split()\n\n\ndef convert_notes_to_beats(notes: List[str]) ->List[int]:\n    \"\"\"Convert the parsed notes into the corresponding number of beats.\n\n    Parameters:\n    notes: List[str] - A list of individual notes.\n\n    Returns:\n    List[int] - A list of integers corresponding to how many beats each note lasts.\n\n    >>> convert_notes_to_beats(['o', 'o|', '.|', 'o|', 'o|', '.|', '.|', '.|', '.|', 'o', 'o'])\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    beats = []\n    for note in notes:\n        if '|' in note:\n            if note == 'o|':\n                beats.append(2)\n            else:\n                beats.append(1)\n        elif note == 'o':\n            beats.append(4)\n        else:\n            beats.append(1)\n    return beats\n"}
{"name": "HumanEval_79_decimal_to_binary", "language": "py", "prompt": "def decimal_to_binary(decimal: int) -> str:\n    \"\"\"You will be given a number in decimal form and your task is to convert it to\n    binary format. The function should return a string, with each character representing a binary\n    number. Each character in the string will be '0' or '1'.\n\n    There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    The extra characters are there to help with the format.\n\n    Examples:\n    >>> decimal_to_binary(15)\n    'db1111db'\n    >>> decimal_to_binary(32)\n    'db100000db'\n    \"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_79_decimal_to_binary.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "decimal_to_binary", "test": "def check(candidate):\n    assert candidate(0) == 'db0db'\n    assert candidate(32) == 'db100000db'\n    assert candidate(103) == 'db1100111db'\n    assert candidate(15) == 'db1111db'\n\ndef test_check():\n    check(decimal_to_binary)\n\ntest_check()\n", "is_solved": true, "test_feedback": [], "solution": "def decimal_to_binary(decimal: int) -> str:\n    \"\"\"You will be given a number in decimal form and your task is to convert it to\n    binary format. The function should return a string, with each character representing a binary\n    number. Each character in the string will be '0' or '1'.\n\n    There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    The extra characters are there to help with the format.\n\n    Examples:\n    >>> decimal_to_binary(15)\n    'db1111db'\n    >>> decimal_to_binary(32)\n    'db100000db'\n    \"\"\"\n    binary = convert_to_binary(decimal)\n    return 'db' + binary + 'db'\n\ndef convert_to_binary(decimal: int) ->str:\n    \"\"\"Converts a decimal number to binary format.\n\n    Parameters:\n    decimal: int - The decimal number to convert.\n\n    Returns:\n    str - The binary representation of the decimal number.\n\n    Examples:\n    >>> convert_to_binary(15)\n    '1111'\n    >>> convert_to_binary(32)\n    '100000'\n    \"\"\"\n    return bin(decimal)[2:]\n"}
{"name": "HumanEval_14_all_prefixes", "language": "py", "prompt": "from typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_14_all_prefixes.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "all_prefixes", "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n\ndef test_check():\n    check(all_prefixes)\n\ntest_check()\n", "is_solved": true, "test_feedback": [], "solution": "def all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n    prefixes = get_all_prefixes(string)\n    return prefixes\n\ndef get_all_prefixes(string: str) ->List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    Parameters:\n    string: str - The input string.\n\n    Returns:\n    List[str] - A list of all prefixes from shortest to longest of the input string.\n\n    >>> get_all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    >>> get_all_prefixes('hello')\n    ['h', 'he', 'hel', 'hell', 'hello']\n    >>> get_all_prefixes('12345')\n    ['1', '12', '123', '1234', '12345']\n    \"\"\"\n    return [string[:i + 1] for i in range(len(string))]\n"}
{"name": "HumanEval_53_add", "language": "py", "prompt": "def add(x: int, y: int) -> int:\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_53_add.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "add", "test": "def check(candidate):\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\ndef test_check():\n    check(add)\n\ntest_check()\n", "is_solved": true, "test_feedback": [], "solution": "def add(x: int, y: int) -> int:\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return x + y"}
{"name": "HumanEval_159_eat", "language": "py", "prompt": "from typing import List\n\ndef eat(number: int, need: int, remaining: int) -> List[int]:\n    \"\"\"\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>> eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_159_eat.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "eat", "test": "def check(candidate):\n    assert candidate(5, 6, 10) == [11, 4]\n    assert candidate(4, 8, 9) == [12, 1]\n    assert candidate(1, 10, 10) == [11, 0]\n    assert candidate(2, 11, 5) == [7, 0]\n    assert candidate(4, 5, 7) == [9, 2]\n    assert candidate(4, 5, 1) == [5, 0]\n\ndef test_check():\n    check(eat)\n\ntest_check()\n", "is_solved": false, "test_feedback": [], "solution": "def eat(number: int, need: int, remaining: int) -> List[int]:\n    \"\"\"\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>> eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\n    total_eaten = number + need\n    remaining_carrots = remaining - need if remaining >= need else 0\n    return [total_eaten, remaining_carrots]\n\ndef total_eaten(number: int, need: int) ->int:\n    \"\"\"\n    Calculate the total number of eaten carrots after your meals.\n\n    Parameters:\n    number: int - The number of carrots that you have eaten.\n    need: int - The number of carrots that you need to eat.\n\n    Returns:\n    int - The total number of eaten carrots after your meals.\n\n    >>> total_eaten(5, 6)\n    11\n    >>> total_eaten(4, 8)\n    12\n    >>> total_eaten(1, 10)\n    11\n    \"\"\"\n    return number + need\n\n\ndef remaining_carrots(remaining: int, need: int) ->int:\n    \"\"\"\n    Calculate the number of carrots left after your meals.\n\n    Parameters:\n    remaining: int - The number of remaining carrots that exist in stock.\n    need: int - The number of carrots that you need to eat.\n\n    Returns:\n    int - The number of carrots left after your meals.\n\n    >>> remaining_carrots(10, 6)\n    4\n    >>> remaining_carrots(9, 8)\n    1\n    >>> remaining_carrots(10, 10)\n    0\n    \"\"\"\n    return remaining - need\n"}
{"name": "HumanEval_115_max_fill", "language": "py", "prompt": "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output the number of times you need to lower the buckets.\n\n    Example 1:\n    >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n    6\n\n    Example 2:\n    >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)\n    5\n    \n    Example 3:\n    >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n    0\n\n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n    \"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_115_max_fill.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "max_fill", "test": "def check(candidate):\n    assert candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1) == 6\n    assert candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2) == 5\n    assert candidate([[0, 0, 0], [0, 0, 0]], 5) == 0\n    assert candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2) == 4\n    assert candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9) == 2\n\ndef test_check():\n    check(max_fill)\n\ntest_check()\n", "is_solved": true, "test_feedback": [], "solution": "def max_fill(grid: List[List[int]], capacity: int) ->int:\n    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output the number of times you need to lower the buckets.\n\n    Example 1:\n    >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n    6\n\n    Example 2:\n    >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)\n    5\n    \n    Example 3:\n    >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n    0\n\n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n    \"\"\"\n    num_times_lowered = 0\n    for well in grid:\n        num_times_lowered += empty_well(well, capacity)\n    return num_times_lowered\n\n\ndef empty_well(well: List[int], capacity: int) ->int:\n    \"\"\"\n    Calculate the number of times a bucket needs to be lowered to empty a single well.\n\n    Parameters:\n    well: List[int] - A list representing a single well, where 1 represents a unit of water.\n    capacity: int - The capacity of the bucket.\n\n    Returns:\n    int - The number of times the bucket needs to be lowered to empty the well.\n\n    >>> empty_well([0, 0, 1, 0], 1)\n    1\n    >>> empty_well([0, 1, 0, 0], 1)\n    1\n    >>> empty_well([1, 1, 1, 1], 1)\n    4\n    \"\"\"\n    return sum(well) // capacity + (1 if sum(well) % capacity != 0 else 0)\n"}
{"name": "HumanEval_160_do_algebra", "language": "py", "prompt": "from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    \"\"\"\n    Given two lists operator, and operand. The first list has basic algebra operations, and \n    the second list is a list of integers. Use the two given lists to build the algebric \n    expression and return the evaluation of this expression.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    Example:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    \"\"\"\n", "doctests": "transform", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_160_do_algebra.py", "prompt_terminology": "reworded", "stop_tokens": ["\ndef", "\n#", "\nif", "\nclass"], "entry_point": "do_algebra", "test": "def check(candidate):\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['//', '*'], [7, 3, 4]) == 8\n\ndef test_check():\n    check(do_algebra)\n\ntest_check()\n", "is_solved": true, "test_feedback": [], "solution": "def do_algebra(operator: List[str], operand: List[int]) -> int:\n    \"\"\"\n    Given two lists operator, and operand. The first list has basic algebra operations, and \n    the second list is a list of integers. Use the two given lists to build the algebric \n    expression and return the evaluation of this expression.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    Example:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    \"\"\"\n    expression = build_expression(operator, operand)\n    result = evaluate_expression(expression)\n    return result\n\ndef build_expression(operator: List[str], operand: List[int]) ->str:\n    \"\"\"\n    Build the algebraic expression using the given lists of operators and operands.\n\n    Parameters:\n    operator: List[str] - A list of basic algebra operations.\n    operand: List[int] - A list of integers.\n\n    Returns:\n    str - The algebraic expression built using the given operators and operands.\n\n    >>> build_expression(['+', '*', '-'], [2, 3, 4, 5])\n    \"2 + 3 * 4 - 5\"\n    >>> build_expression(['-', '+', '*'], [5, 4, 3, 2])\n    \"5 - 4 + 3 * 2\"\n    >>> build_expression(['*', '+', '-'], [1, 2, 3, 4, 5])\n    \"1 * 2 + 3 - 4 * 5\"\n    \"\"\"\n    expression = str(operand[0])\n    for i in range(1, len(operand)):\n        expression += ' ' + operator[i - 1] + ' ' + str(operand[i])\n    return expression\n\n\ndef evaluate_expression(expression: str) ->int:\n    \"\"\"\n    Evaluate the given algebraic expression and return the result.\n\n    Parameters:\n    expression: str - The algebraic expression to be evaluated.\n\n    Returns:\n    int - The result of the evaluated algebraic expression.\n\n    >>> evaluate_expression(\"2 + 3 * 4 - 5\")\n    9\n    >>> evaluate_expression(\"5 - 4 + 3 * 2\")\n    7\n    >>> evaluate_expression(\"1 * 2 + 3 - 4 * 5\")\n    -16\n    \"\"\"\n    return eval(expression)\n"}
